/**
 * Simulation state at a given time.
 *
 * Contains the current robot state and all messages generated by the simulation to date.
 * 
 * robot - The robot state at this point in time
 * messages - All messages generated by running the program
 *  
 */
case class Simulation(robot:Robot, messages:Array[String]) { 
  
  // Command parsing patterns
  val place_pattern = """^PLACE ([0-9]+),([0-9]+),(NORTH|SOUTH|EAST|WEST)$""".r
  val move_pattern = """^MOVE$""".r
  val left_pattern = """^LEFT$""".r
  val right_pattern = """^RIGHT$""".r
  val report_pattern = """^REPORT$""".r
  
  /** 
   * Execute a simulation command.
   * 
   * Given a command string, parses the command and returns an updated simulation state.
   * If the command is invalid it posts the message "INVALID COMMAND" to the
   * messages.
   *  
   **/
  def execute(input: String) = {
    input match {
      case place_pattern(x,y,facing) =>
        Simulation(
            robot.place(x.toInt, y.toInt, Facing.parse(facing)),
            messages)
        
      case move_pattern() => Simulation(robot.move(), messages)
      case left_pattern() => Simulation(robot.left(), messages)
      case right_pattern() => Simulation(robot.right(), messages)
      case report_pattern() =>
        if (robot.placed)
          Simulation(robot, messages :+ robot.report())
        else
          this
      case _ => Simulation(robot, messages :+ "INVALID COMMAND")
    }
  }
  
}

object Simulation {
  
  /**
   * Make a new simulation
   */
  def make(): Simulation = new Simulation(Robot.make(), new Array[String](0))

  /** 
  * Run a robot program
  *
  * program - Robot program as sequence of text strings.
  * 
  * returns - The final simulation state. Robot will be at its resting
  * place and messages will contain all reports generated during
  * execution.
  *  
  **/
  def run(program: Seq[String]): Simulation = {
    return program.foldLeft(Simulation.make())((s,c) => s.execute(c))
  }
  
}